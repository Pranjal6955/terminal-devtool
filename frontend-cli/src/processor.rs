use std::{process::Command, path::Path};
use anyhow::{Result, Context};
use colored::*;
use prettytable::{Table, row, cell};

use crate::{cli::{CliArgs, Commands}, client::ApiClient, models::{ProcessRequest, MediaInfo, CompareResult}};

pub fn process_media(args: CliArgs) -> Result<()> {
    // Create API client if not in local mode
    let client = if !args.local {
        Some(ApiClient::new(args.backend_url))
    } else {
        None
    };
    
    // Check backend health if using API
    if let Some(client) = &client {
        if let Err(e) = client.check_health() {
            eprintln!("{} {}", "‚ö†Ô∏è".yellow(), format!("Backend connection failed: {}", e).yellow());
            eprintln!("{} {}", "‚ÑπÔ∏è".blue(), "Falling back to local mode.".blue());
        }
    }
    
    match args.command {
        Commands::Process { 
            input,
            output,
            resolution,
            bitrate,
            format,
            dry_run
        } => {
            process_command(client, input, output, resolution, bitrate, format, dry_run)?;
        },
        Commands::Compare { 
            original, 
            processed 
        } => {
            compare_command(client, &original, &processed)?;
        },
        Commands::Info { 
            file 
        } => {
            info_command(client, &file)?;
        },
        Commands::Convert {
            input,
            output,
            format
        } => {
            // Print dry-run message
            let output_str = if let Some(ref out) = output {
                out.as_str()
            } else {
                "<auto-generated>"
            };
            println!(
                "[Dry Run] Converting {} to {} format... (output: {})",
                input, format, output_str
            );
        }
    }
    
    Ok(())
}

fn process_command(
    client: Option<ApiClient>,
    input: String,
    output: Option<String>,
    resolution: Option<String>,
    bitrate: Option<String>,
    format: Option<String>,
    dry_run: bool
) -> Result<()> {
    if dry_run {
        println!("{} {}", "üîç".bright_blue(), "Dry run mode - displaying command without executing...".bright_blue());
    } else {
        println!("{} {}", "üé¨".bright_green(), "Starting media processing...".bright_green());
    }
    
    // Use API client if available
    if let Some(client) = client {
        let request = ProcessRequest {
            input: input.clone(),
            output: output.clone(),
            resolution: resolution.clone(),
            bitrate: bitrate.clone(),
            format: format.clone(),
            dry_run,
        };
        
        println!("{} {}", "üåê".cyan(), "Sending request to backend server...".cyan());
        
        match client.process_media(request) {
            Ok(response) => {
                println!("{} {}", "‚úÖ".green(), format!("Processing complete. Output: {}", response.output).green());
                return Ok(());
            },
            Err(e) => {
                eprintln!("{} {}", "‚ö†Ô∏è".yellow(), format!("Backend processing failed: {}", e).yellow());
                eprintln!("{} {}", "‚ÑπÔ∏è".blue(), "Falling back to local processing...".blue());
            }
        }
    }
    
    // Fall back to local processing
    let output = output.unwrap_or_else(|| {
        let output_name = format!("processed_{}", Path::new(&input).file_name().unwrap().to_string_lossy());
        if let Some(fmt) = &format {
            return format!("{}.{}", output_name, fmt);
        }
        output_name.to_string()
    });
    
    let mut ffmpeg_args = vec!["-i", &input];
    
    if let Some(res) = &resolution {
        ffmpeg_args.push("-s");
        ffmpeg_args.push(res);
    }
    
    if let Some(br) = &bitrate {
        ffmpeg_args.push("-b:v");
        ffmpeg_args.push(br);
    }
    
    ffmpeg_args.push(&output);
    
    // Build command string
    let cmd_string = format!("ffmpeg {}", ffmpeg_args.join(" "));
    
    if dry_run {
        // Just print the command that would be run
        println!("{} {}", "üìù".bright_blue(), format!("[Dry Run] {}", cmd_string).bright_blue());
        return Ok(());
    }
    
    println!("{} {}", "üõ†Ô∏è".yellow(), format!("Running ffmpeg locally with args: {:?}", ffmpeg_args).yellow());
    
    let status = Command::new("ffmpeg")
        .args(&ffmpeg_args)
        .status()
        .context("Failed to execute ffmpeg")?;
        
    if status.success() {
        println!("{} {}", "‚úÖ".green(), format!("Processing complete. Output: {}", output).green());
    } else {
        eprintln!("{} {}", "‚ùå".red(), "Processing failed".red());
        return Err(anyhow::anyhow!("ffmpeg command failed"));
    }
    
    Ok(())
}

fn compare_command(client: Option<ApiClient>, original: &str, processed: &str) -> Result<()> {
    println!("{} {}", "üîç".bright_green(), "Comparing media files...".bright_green());
    
    let result = if let Some(client) = client {
        println!("{} {}", "üåê".cyan(), "Sending comparison request to backend server...".cyan());
        client.compare_media(original, processed)?
    } else {
        // Local comparison not implemented - would require ffprobe parsing
        return Err(anyhow::anyhow!("Local comparison requires backend server"));
    };
    
    print_comparison_result(&result);
    
    Ok(())
}

fn info_command(client: Option<ApiClient>, file_path: &str) -> Result<()> {
    println!("{} {}", "‚ÑπÔ∏è".bright_green(), format!("Getting info for {}...", file_path).bright_green());
    
    let info = if let Some(client) = client {
        println!("{} {}", "üåê".cyan(), "Sending info request to backend server...".cyan());
        client.get_media_info(file_path)?
    } else {
        // Local info not implemented - would require ffprobe parsing
        return Err(anyhow::anyhow!("Local media info requires backend server"));
    };
    
    print_media_info(&info);
    
    Ok(())
}

fn print_media_info(info: &MediaInfo) {
    let mut table = Table::new();
    
    table.add_row(row!["Property", "Value"]);
    table.add_row(row!["Filename", &info.filename]);
    table.add_row(row!["Format", &info.format]);
    table.add_row(row!["Duration", &info.duration]);
    table.add_row(row!["Resolution", &info.resolution]);
    table.add_row(row!["Bitrate", &info.bitrate]);
    table.add_row(row!["Size (bytes)", &info.size.to_string()]);
    
    println!();
    table.printstd();
    println!();
}

fn print_comparison_result(result: &CompareResult) {
    let mut table = Table::new();
    
    table.add_row(row!["Property", "Original", "Processed"]);
    table.add_row(row!["Filename", &result.original.filename, &result.processed.filename]);
    table.add_row(row!["Format", &result.original.format, &result.processed.format]);
    table.add_row(row!["Resolution", &result.original.resolution, &result.processed.resolution]);
    table.add_row(row!["Bitrate", &result.original.bitrate, &result.processed.bitrate]);
    table.add_row(row!["Size (bytes)", 
                       &result.original.size.to_string(), 
                       &result.processed.size.to_string()]);
    
    println!();
    table.printstd();
    println!();
    
    // Print size difference
    let diff_text = format!("Size reduction: {:.2}%", result.size_diff_percent);
    if result.size_diff_percent > 0.0 {
        println!("{} {}", "üîΩ".green(), diff_text.green());
    } else if result.size_diff_percent < 0.0 {
        println!("{} {}", "üîº".red(), diff_text.red());
    } else {
        println!("{} {}", "‚öñÔ∏è", diff_text);
    }
    
    println!();
}
